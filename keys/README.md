# JSON Web Keys

Access to the service is protected by the need for a [JSON Web Token (JWT)](https://jwt.io/introduction/). A JWT is a standard for sending information between parties that is secure and compact. Because of this they are commonly used as a means of authenticating with API's.

The service uses [Amazon Cognito](https://docs.aws.amazon.com/cognito/latest/developerguide/what-is-amazon-cognito.html) to manage our 'users' (authorised systems) and to generate JWTs.

The client system authenticates with Cognito which then returns a JWT. They then pass that JWT in a `Authorization` header in the format `Bearer [JWT token]` to our API. This is all based on the [OAuth2 protocol](https://oauth.net/2/) for authentication. A valid JWT is proof the client system has sucessfully authenticated.

Cognito signs the JWT with a private key. You can verify the JWT by using a public version of the key. Their public keys are provided as a [JSON Web Key (JWK)](https://tools.ietf.org/html/rfc7517). This is like any other key, only expressed in JSON format.

Each of our environments connects to a different [Cognito User Pool](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html), and each pool will use a couple of private keys for the encoding. This is why we have a file for each environment, and each file holds a copy of 2 public keys.

The private keys are generated when the Cognito User Pool is and then used until manually updated. This is why obtaining the public keys is a onetime operation and there is no need to keep checking and updating them.

> For reference you need the region and `UserPoolId` for the Cognito environment you wish to verify against. You can then access the public JWKs at `https://cognito-idp.{region}.amazonaws.com/{userPoolId}/.well-known/jwks.json`.

## Parts of a JWT

JWT tokens include three sections: a header, payload, and signature.

> It's important to get clear that JWTs are not encrypted. If you have a JWT you can paste it into a site like <https://jwt.io/> and decode it instantly. The private keys are used to sign it, and the public keys in this folder are part of the process which verifies the signature.

The header contains the key ID `kid`, as well as the algorithm `alg` used to sign the token.

```json
{
  "kid": "abcdefghijklmnopqrsexample=",
  "alg": "RS256"
}
```

The payload of a JWT will differ based on who generated it. With Cognito it will look something like this.

```json
{
  "sub": "aaaaaaaa-bbbb-cccc-dddd-example",
  "token_use": "access",
  "scope": "charging-module-api-dev/v1",
  "auth_time": 1601652401,
  "iss": "https://cognito-idp.eu-west-1.amazonaws.com/eu-west-1_example",
  "exp": 1601656001,
  "iat": 1601652401,
  "version": 2,
  "jti": "5d419243-21f3-44a2-adf3-cd2933522957",
  "client_id": "cognitoclientidprovidedtotheclientsystem"
}
```

For us the critical property is the `client_id`. This is what we use to identify the client system making the request to the API.

The final part is the signature. When decoded on a site like <https://jwt.io/> you'll see a copy of the public key you can use to verify the token.

## Our use of the JWKs

All requests to endpoints that require authentication will first be checked for a valid and verified JWT. We use the [hapi-now-auth](https://github.com/now-ims/hapi-now-auth) plugin to confirm the request contains a bearer token. It also handles decoding and verifying the JW. But to do that it needs the relevant keys in [PEM format](http://www.logicio.com/HTML/security-file-format.htm).

We created the [CognitoJwtToPemService](app/services/cognito_jwt_to_pem.service.js) to handle both reading the right JWKs from file and using [jwk-to-pem](https://github.com/Brightspace/node-jwk-to-pem) to convert them to PEM format.

**hapi-now-auth** will iterate through the keys provided until it finds one where verification is successful.

It returns to us the decoded token as seen in [jwt_strategy.auth.js](app/auth/jwt_strategy.auth.js). From it we extract the `clientId` which we then add to a `credentials` object. It *must* be called `credentials` and *must* be an object. This gets added to the Hapi request object automatically by the plugin.

## Client system use of the JWKs

It is up to each team which uses our API to decide whether to use the JWKs we provide here. Doing so means they can verify the Cognito bearer tokens they obtain were in fact generated by our Cognito instances.

For those using Node.js it should be relatively simple to extract the code we use and apply it.

## There's a key in your source code!

To be clear, what is saved here is the **public** version of the private key used to sign the JWK's. A public key is by its name intended to be made available publically to allow systems to use it safely. Specifically in the case of JWT's, anyone obtaining a token is encouraged to verify the token came from an expected source, our AWS Cognito instances in this case, to protect against any [man-in-the-middle attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack).

These public JWKs are also obtainable from the JWT. Using <https://jwt.io/> you first decode the token. The decoded info will include a PEM encoded copy of the public key. You can then take that to a site like [JWK Creator](https://russelldavies.github.io/jwk-creator/) and generate a JWK as seen in this folder.

## References

- [Verifying a JSON Web Token](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html)
- [Decode and verify Amazon Cognito JWT tokens](https://github.com/awslabs/aws-support-tools/tree/master/Cognito/decode-verify-jwt)
